# Glossary of Terms

本ファイルに記載される用語の定義は、  
Klaus Iglberger 著, 千住 治郎 訳, C++ソフトウェア設計―高品質設計の原則とデザインパターン, オライリー・ジャパン, 2023  
を出典とする。

#### ソフトウェア設計 (Software Design)

> ソフトウェア設計とは、ソフトウェアコンポーネント感の依存関係を管理する技である。人工的（技術的）依存関係を最小化し、必要な抽象化を導入し、妥協点を見出すことを目的とする。

(4p, ガイドライン 1)

#### ソフトウェアアーキテクチャ (Software Architecture)

e.g., クライアント/サーバアーキテクチャ, マイクロサービス

> 普遍的に認められる一般的な定義が存在しないためです。
> （中略）
> 誰もが認める点が１つあります、ソフトウェアアーキテクチャとは、一般に全体に係る判断を下すものという点です。すなわち、将来変更するのがもっとも困難な部分です。

(6p, ガイドライン 1)

#### (C++)イディオム (C++ Idiom)

e.g., RAII, Pimpl, ...

> イディオムとは、その言語に固有とはいえ、よくある問題に対し広く用いられる解です。パターンとも言えます。

> 大雑把に言えば C++イディオムは、C++コミュニティが生んだ、設計または実装に使える実践技です。

(7p, ガイドライン 1)

#### SOLID 原則 (SOLID Principles)

> SOLID とは以降のガイドラインで述べる SRP, OCP, LSP, ISP, DIP、５つの設計原則の略語を集め、その頭文字をつなげた名前です

(10p, ガイドライン 2)

#### 単一責任の原則 (SRP; Single Responsibility Principle)

syn.: 関心の分離 (Separation of Concerns), 直交性 (Orthogonality), 凝集力 (Cohesion), 疎結合 (Loose Coupling)

> クラスを変更する理由は１つだけであるべきである

(9p, ガイドライン 2)

> SRP が言っているのは、関心と、真に属さないもの、すなわち非凝集性（癒着性）のものとを、分離すべきということです。言い換えると、変更する原因が異なるものはバリエーションポイント (variation point) に分離せよということです。

(14p, ガイドライン 2)

#### 上位 (High-level) / 下位 (Low-level)

> 上位 (high level) とはアーキテクチャで安定している部分を、
> 下位 (low level) とは多く変更されるもの、もしくは変更されやすいものを、それぞれ意味します。

(14p, ガイドライン 2)

> 上位、すなわち開発ソフトウェアの安定している部分は、下位、すなわち実装詳細に、依存するべきではありません。そのような依存関係があれば逆転させなければなりません。

(63p, ガイドライン 9)

#### バリエーションポイント (Variation Point)

> （略）バリエーションポイント、すなわちコードの変更が予想されるアスペクト

(15p, ガイドライン 2)

#### DRY 原則 (DRY; Don't Repeat Yourself)

> SRP がバリエーションポイントの分離を言うように、開発コード全体を通じ情報が重複しないよう注意すべきです。すべての場面で単一責任（変更理由は１つだけである）を実現すべきであり、個々の責任はシステム内で１ヶ所にしか存在しないようにすべきです。この考え方を一般に DRY 原則 (Don't Repeat Yourself) と言います。重要な情報を複数箇所に記述してはならない―変更が１ヶ所で済むようなシステムを設計しなさい、という意味です。

(20p, ガイドライン 2)

#### インターフェース分離の原則 (ISP; Interface Segregation Principle)

SOLID 原則の I。
使用しないメソッドへの依存をクライアントに強制すべきでない。
関心の分離が目的であり、そのための手段としてインターフェースの分離をすべきといっている。

> ISP はインターフェースに特化した、SRP の特殊なケースであるとも言えます。

(24p, ガイドライン 3)

#### 開放/閉鎖原則（OCP; Open-Closed Principle）

SOLID 原則の O。
拡張は既存のコードの改造なしに行えるべきである。
より詳しくは、同じレベル、上位レベルの既存コードで変更を発生させるべきではないが、下位レベルの変更発生は許容される。
ソフトウェアが将来どう拡張されるかを意識的に検討し、その拡張が容易に行えるよう、関心の分離を行うことを要求している。

> ソフトウェアコンポーネント（クラス、モジュール、関数など）は、拡張に対してはオープンに、改造に対してはクローズに、すべきである。

(35p, ガイドライン 5)

> OCP は SRP よりも拡張性の認識とその意識的な決定に重点を置いており、SRP の単なる付随物以上の存在と言えるでしょう。

(36p, ガイドライン 5)

#### クローズセット/オープンセット (Closed Set/Open Set)

クローズセットは変更を許容しない（または困難な）範囲、オープンセットとは、変更を許容する（または容易な）範囲のことです。

(103p, ガイドライン 16)

#### 抽象化 (Abstraction)

> 抽象化とは要件や期待する動作を表現するもの、と理解する。

(49p, ガイドライン 7)

#### リスコフの置換原則 (LSP; Liskov Substitution Principle)

SOLID 原則の L。
基底クラスを継承した派生クラス（サブタイプ）は、IS-A 関係を遵守（常に保証）しなければならない。

(44p, ガイドライン 6)

#### IA-A 関係 (IS-A Relationship)

あるスーパータイプ T とそのサブタイプ S について、以下のような性質を満たすときの T と S の関係を IS-A 関係という。

- サブタイプは、スーパータイプの事前条件を強化してはならない。
  - 事前条件：関数の引数に関する条件
- サブタイプは、スーパータイプの事後条件を弱めてはならない。
  - 事後条件：関数の戻り値に関する条件
- サブタイプの関数戻り値は、共変 (covariant) でなければならない。
  - 共変："サブタイプの関数の戻り値の型"が、"スーパータイプの関数の戻り値の型"のサブタイプであること
    - B が A のサブタイプならば、`B f()` は `A f()` のサブタイプである。
    - サブタイプは、戻り値でサブタイプを返せる。
- サブタイプの関数パラメータは、半変 (contravariant) でなければならない。
  - 半変："サブタイプの関数の引数の型"が、"スーパータイプの関数の引数の型"のサブタイプであること
    - B が A のサブタイプならば、`void f(B)` は `void f(A)` のサブタイプである。
    - サブタイプは、引数でスーパータイプを受け取れる。
- スーパータイプの不変条件は、サブタイプでも維持されなければならない。
  - 不変条件：タイプの状態に期待される内容で、全てのメンバ関数呼出の前後で常に有効であるもの。

(45p, ガイドライン 6)

#### コンセプト (Concept)

本書のコンセプトという用語は、その形を問わず、要件を表現するものを指す。
C++20 のコンセプトに加えて、テンプレート引数もコンセプトとして扱う。（テンプレート引数を指す場合の方が多い。）

(52p, ガイドライン 7)

#### フリー関数 (Free Function)

C++において、非メンバー関数を指す。

#### 依存関係逆転の原則 (DIP; Dependency Inversion Principle)

SOLID 原則の D。

> 依存関係を管理するには、具象型や実装詳細ではなく抽象化に依存すべきである、ということです。

(59p, ガイドライン 9)

> DIP も SRP の特殊な例とみなすのが妥当に思えます。（ISP と同様）。
> しかし DIP にはそれ以上のものがあります。
> SRP と比較すると、DIP はアーキテクチャに重点を置いており、正しいグローバルな依存構造を構築するのに非常に大きく影響する原則と、著者は考えます。

(68p, ガイドライン 9)

#### デザインパターン (Design Pattern)

デザインパターンは名前を持ち、明確な目的のための抽象化を導入し、長い年月をかけて検証されてきたソフトウェア設計レベルの解である。

(ガイドライン 11)

#### Visitor パターン

> 目的：あるオブジェクト構造の要素で実行されるオペレーションを表現する。
> Visitor パターンにより、オペレーションを加えるオブジェクトのクラスに変更を加えずに、新しいオペレーションを定義することができるようになる。

(106p, ガイドライン 16)

> Visitor パターンでは処理の追加をバリエーションポイント（中略）と考えます。
> このバリエーションポイントを切り出す、すなわち別クラスとすることで、単一責任の原則（SRP）に従っていると言えます。

(109p, ガイドライン 16)

> Visitor パターンでは処理の汎用的な追加をバリエーションポイントとし、処理の抽象化も汎用的に作成し、誰でも追加できるようにしました。
> 残念な副次効果として、型の追加が容易ではなくなってしまいました。

(145p, ガイドライン 19)

#### Strategy パターン

> Strategy パターンでのバリエーションポイントは単一関数の実装詳細です。
> この実装詳細を抽象化しても、型の追加が容易という特徴は失われません。
> しかし、処理の追加は容易ではなく、依然として仮想関数の追加という干渉が必要です。
> Strategy パターンの目的は、Visitor パターンの目的とは逆なのです。

(146p, ガイドライン 19)

> Strategy パターンがもっとも効果を発揮するのは、ごく限られた数の実装詳細を分離する場面です。多数の処理の実装詳細を切り出すような場合は、別のアプローチを検討したほうが容易でしょう（例えば External Polymorphism や Type Erasure など）。

(148p, ガイドライン 19)

> Strategy パターンは、数あるデザインパターンの中でももっとも用途が広いものです。
> （中略）とは言え、どんな問題に対処できる究極の解ではありません。

(150p, ガイドライン 19)

#### Command パターン

種類の異なる処理内容をバリエーションポイントとして、全く異なる処理内容を抽象化して扱えるようにするデザインパターン。
ただし処理内容としては、（基本的に）一度だけしか実行せず、その場ですぐに実行するという性質があることを前提とする。

> 目的：要求をオブジェクトとしてカプセル化することによって、異なる要求や、要求からなるキューやログにより、クライアントをパラメータ化する。また、取り消し可能なオペレーションをサポートする。

(154p, ガイドライン 21)

> 構造的に見れば Strategy パターンと Command パターンは同一です。（中略）
> 両者の目的はその違いにあります。Strategy パターンは何かをどう（how）行うかを表すのに対し、Command パターンでは何を（what）行うかを表現します。

(160p, ガイドライン 21)

（依存オブジェクト注入で）オブジェクトが動作の設定を持てるようになっているなら Strategy パターンと言える。
一方オブジェクトが動作の設定を持たず、（メソッド引数で）渡された動作を直接実行するだけなら Command パターンと言える。
Command パターンでは、処理に関する全ての判断が Command オブジェクト内部で行われる。そのため undo() 処理を実装することが容易である。

(162p, ガイドライン 21)

> Command パターンと Strategy パターンの間にグレーゾーンが存在することは、著者も認めます。

(163p, ガイドライン 21)

> Command パターンにも短所はあります。Strategy パターンと比べるとずっと少なく、真の短所と言えるのは１つしかありません。Command パターンを基底クラスの形で実装した際に発生する、間接参照です。

(164p, ガイドライン 21)

#### セマンティクス (Semantics)

あるプログラム片（コード）が、どのような振る舞い（＝意味）を持つかを決める決まり。

- e.g., 「 `std::span` のセマンティクスは、ポインタと同じである。」
- e,g., コピーセマンティクス：代入操作のコードを書いたとき、それが参照を渡す振る舞いか、真の値コピーを行う振る舞いのどちらを意味するか、を決めるもの。
- e.g., 参照セマンティクス/値セマンティクス：コピー（代入、コンストラクタ呼出）操作のコードを書くと、それが参照を渡す/真の値コピーを行う振る舞いである、ということを示す。

(ガイドライン 22)

#### Adapter パターン

> 目的：あるクラスのインターフェースを、クライアントが求める他のインターフェースへ変換する。Adapter パターンは、インターフェースに互換性のないクラス同士を組み合わせることができるようにする。

(187p, ガイドライン 24)

求められるインターフェースを持つラッパークラスを実装すること。

> Adapter パターンは、関数セットを別の関数セットへマッピングする、間接参照であるとも言えます。１関数を厳密に別の１関数へマッピングしなくともよい点に注意してください。

(188p, ガイドライン 24)

> 構造的に見れば、Strategy パターンと Adapter パターンはとても良くにています。しかし、「ガイドライン１１」でも述べたように、（中略）その目的が異なるのです。
> （中略）
> Adapter パターンの主眼はインターフェースを統一し、非互換の機能を既存の動作へ統合することです。それに対し Strategy パターンは、インターフェースを提供し、動作を外部から設定可能にすることを主眼としています。さらに Adapter パターンでは、どの時点でも動作を再設定する必要がありません。

(192p, ガイドライン 24)

> （訳注：Adapter パターンには、）既存の階層構造に別種のものでも容易に組み込めてしまうリスク（がある。）
> そのため、Adapter パターンを用いる際には、期待される動作をよく検討し、LSP から逸脱していないかをよく確認する事が重要なのです。

(195p, ガイドライン 24)

#### オブジェクトアダプタ/クラスアダプタ (Object Adapter/Class Adapter)

- オブジェクトアダプタ：ラップしたい型のインスタンスを内部に保持する Adapter クラス。
- クラスアダプタ：ラップしたい型を継承する Adapter クラス。

> 一般にクラスアダプタよりもオブジェクトアダプタの方が、柔軟性が高いことが実証されており優先すべきアプローチです。

(189p, ガイドライン 24)

#### コンテナ (Container)

コンテナライブラリ (Container Library) で提供される、一般的なデータ構造（リスト、キュー、スタックなど）を表すクラス（の呼び名）。

- e.g., `std::vector` はシーケンシャルコンテナの一種である。
- e.g., コンテナアダプタ：シーケンシャルコンテナに、特定のインターフェースを提供するためのアダプタクラス (e.g., `std::stack`, `std::queue`)

(ガイドライン 24)

#### Observer パターン

サブジェクト（観察対象）と複数のオブザーバ（観察者）を分離しつつ、サブジェクトに状態変化が発生したらすぐにオブサーバに通知するためのデザイン。

> 目的：あるオブジェクトが状態を変えたときに、それに依存するすべてのオブジェクトに自動的にそのことが知らされ、また、それらが更新されるおうに、オブジェクト間に一対多の依存関係を定義する。

(197p, ガイドライン 25)

> Observer パターンでは新規オブザーバの追加ー一対多関係の依存関係の拡張ーをバリエーションポイントとします。

(197p, ガイドライン 25)

#### CRTP パターン (Curiously Recurring Template Pattern; 奇妙に再帰したテンプレートパターン)

継承を使った抽象化をしながら、性能を低下させないためのテンプレートパターン。
仮想関数を使わずコンパイル時に解決されるテンプレートを用いることで、性能低下を避けている。

> 目的：型ファミリのコンパイル時抽象化を定義する。

(217p, ガイドライン 26)

> 最初に挙げる短所はもっとも大きな制約でもある、共通する基底クラスが存在しない点です。
> （中略）
> 実質的にすべての派生クラスには、それぞれ異なる基底クラスがあります。
> （中略）
> 共通する基底クラスや抽象化が必要な場面、例えばなんらかのコレクション内に異なる型を保持する等の場合では、CRTP パターンは正しい解にはなりません。

(222p, ガイドライン 26)

> ２つ目のやはり大きな制約となるおそれがある点は、CRTP 基底クラスと関係するものは、すべてそれ自身がテンプレートになることです。
> （中略）
> コードの多くをテンプレート化し、定義をヘッダ似移動するなど、好ましいどころか極力避けるべき事態です。せっかくソースファイルにカプセル化したのが無駄になってしまいます。

(223p, ガイドライン 26)

> 重要なこととして、CRTP パターンは実行時多態ではなく、コンパイル時多態という機能しか備えていない点です。なんらかの静的な抽象化の場面でのみ使えるデザインパターンであり、それ以外の場面では継承階層を置き換えるなどできません。

(223p, ガイドライン 26)

> 実際 C++20 のコンセプトは CRTP パターンによく似ている上、簡潔に表現でき干渉もしません。
> 特に干渉しない点は重要で、C++20 のコンセプトならば一連の型を静的に定義できます。
> CRTP パターンよりもコンセプトを優先すべきです。

(222p, ガイドライン 26)

#### デザインパターン比較表

| パターン | バリエーションポイント | 型の追加     | 処理の追加   | 類似パターン |
| -------- | ---------------------- | ------------ | ------------ | ------------ |
| Visitor  | 処理の追加             | 容易ではない | 容易         | -            |
| Strategy | 単一関数の実装詳細     | 容易         | 容易ではない | Command      |
| Command  | 処理内容               | 容易         | 容易ではない | Strategy     |

###　 Abbreviations

- RAII : Resource Acquisition Is Initialization
  - リソース獲得時初期化
- ADL: Argument-Dependent Lookup
  - 実引数依存の名前探索
- CTAD: Class Template Argument Deduction
  - クラステンプレートのテンプレート引数推論
- SFINAE: Substitution Failure Is Not An Error
  - 置換失敗はエラーとしない
- NTTP: Non-Type Template Parameter
  - 非型テンプレートパラメータ
- IFNDR: Ill-Formed, No Diagnostic Required
  - 厳密には誤りだが、診断は必要ない -　 SIOF: Static Initialization Order Fiasco
  - 静的初期化順序の混乱
