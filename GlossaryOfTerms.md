# Glossary of Terms

本ファイルに記載される用語の定義は、  
Klaus Iglberger 著, 千住 治郎 訳, C++ソフトウェア設計―高品質設計の原則とデザインパターン, オライリー・ジャパン, 2023  
を出典とする。

#### ソフトウェア設計 (Software Design)

> ソフトウェア設計とは、ソフトウェアコンポーネント感の依存関係を管理する技である。人工的（技術的）依存関係を最小化し、必要な抽象化を導入し、妥協点を見出すことを目的とする。

(4p, ガイドライン 1)

#### ソフトウェアアーキテクチャ (Software Architecture)

e.g., クライアント/サーバアーキテクチャ, マイクロサービス

> 普遍的に認められる一般的な定義が存在しないためです。
> （中略）
> 誰もが認める点が１つあります、ソフトウェアアーキテクチャとは、一般に全体に係る判断を下すものという点です。すなわち、将来変更するのがもっとも困難な部分です。

(6p, ガイドライン 1)

#### (C++)イディオム (C++ Idiom)

e.g., RAII, Pimpl, ...

> イディオムとは、その言語に固有とはいえ、よくある問題に対し広く用いられる解です。パターンとも言えます。

> 大雑把に言えば C++イディオムは、C++コミュニティが生んだ、設計または実装に使える実践技です。

(7p, ガイドライン 1)

#### SOLID 原則 (SOLID Principles)

> SOLID とは以降のガイドラインで述べる SRP, OCP, LSP, ISP, DIP、５つの設計原則の略語を集め、その頭文字をつなげた名前です

(10p, ガイドライン 2)

#### 単一責任の原則 (SRP; Single Responsibility Principle)

syn.: 関心の分離 (Separation of Concerns), 直交性 (Orthogonality), 凝集力 (Cohesion), 疎結合 (Loose Coupling)

> クラスを変更する理由は１つだけであるべきである

(9p, ガイドライン 2)

> SRP が言っているのは、関心と、真に属さないもの、すなわち非凝集性（癒着性）のものとを、分離すべきということです。言い換えると、変更する原因が異なるものはバリエーションポイント (variation point) に分離せよということです。

(14p, ガイドライン 2)

#### 上位 (High-level) / 下位 (Low-level)

> 上位 (high level) とはアーキテクチャで安定している部分を、
> 下位 (low level) とは多く変更されるもの、もしくは変更されやすいものを、それぞれ意味します。

(14p, ガイドライン 2)

> 上位、すなわち開発ソフトウェアの安定している部分は、下位、すなわち実装詳細に、依存するべきではありません。そのような依存関係があれば逆転させなければなりません。

(63p, ガイドライン 9)

#### バリエーションポイント (Variation Point)

> （略）バリエーションポイント、すなわちコードの変更が予想されるアスペクト

(15p, ガイドライン 2)

#### DRY 原則 (DRY; Don't Repeat Yourself)

> SRP がバリエーションポイントの分離を言うように、開発コード全体を通じ情報が重複しないよう注意すべきです。すべての場面で単一責任（変更理由は１つだけである）を実現すべきであり、個々の責任はシステム内で１ヶ所にしか存在しないようにすべきです。この考え方を一般に DRY 原則 (Don't Repeat Yourself) と言います。重要な情報を複数箇所に記述してはならない―変更が１ヶ所で済むようなシステムを設計しなさい、という意味です。

(20p, ガイドライン 2)

#### インターフェース分離の原則 (ISP; Interface Segregation Principle)

SOLID 原則の I。
使用しないメソッドへの依存をクライアントに強制すべきでない。
関心の分離が目的であり、そのための手段としてインターフェースの分離をすべきといっている。

> ISP はインターフェースに特化した、SRP の特殊なケースであるとも言えます。

(24p, ガイドライン 3)

#### 開放/閉鎖原則（OCP; Open-Closed Principle）

SOLID 原則の O。
拡張は既存のコードの改造なしに行えるべきである。
より詳しくは、同じレベル、上位レベルの既存コードで変更を発生させるべきではないが、下位レベルの変更発生は許容される。
ソフトウェアが将来どう拡張されるかを意識的に検討し、その拡張が容易に行えるよう、関心の分離を行うことを要求している。

> ソフトウェアコンポーネント（クラス、モジュール、関数など）は、拡張に対してはオープンに、改造に対してはクローズに、すべきである。

(35p, ガイドライン 5)

> OCP は SRP よりも拡張性の認識とその意識的な決定に重点を置いており、SRP の単なる付随物以上の存在と言えるでしょう。

(36p, ガイドライン 5)

#### クローズセット/オープンセット (Closed Set/Open Set)

クローズセットは変更を許容しない（または困難な）範囲、オープンセットとは、変更を許容する（または容易な）範囲のことです。

(103p, ガイドライン 16)

#### 抽象化 (Abstraction)

> 抽象化とは要件や期待する動作を表現するもの、と理解する。

(49p, ガイドライン 7)

#### リスコフの置換原則 (LSP; Liskov Substitution Principle)

SOLID 原則の L。
基底クラスを継承した派生クラス（サブタイプ）は、IS-A 関係を遵守（常に保証）しなければならない。

(44p, ガイドライン 6)

#### IA-A 関係 (IS-A Relationship)

あるスーパータイプ T とそのサブタイプ S について、以下のような性質を満たすときの T と S の関係を IS-A 関係という。

- サブタイプは、スーパータイプの事前条件を強化してはならない。
  - 事前条件：関数の引数に関する条件
- サブタイプは、スーパータイプの事後条件を弱めてはならない。
  - 事後条件：関数の戻り値に関する条件
- サブタイプの関数戻り値は、共変 (covariant) でなければならない。
  - 共変："サブタイプの関数の戻り値の型"が、"スーパータイプの関数の戻り値の型"のサブタイプであること
    - B が A のサブタイプならば、`B f()` は `A f()` のサブタイプである。
    - サブタイプは、戻り値でサブタイプを返せる。
- サブタイプの関数パラメータは、半変 (contravariant) でなければならない。
  - 半変："サブタイプの関数の引数の型"が、"スーパータイプの関数の引数の型"のサブタイプであること
    - B が A のサブタイプならば、`void f(B)` は `void f(A)` のサブタイプである。
    - サブタイプは、引数でスーパータイプを受け取れる。
- スーパータイプの不変条件は、サブタイプでも維持されなければならない。
  - 不変条件：タイプの状態に期待される内容で、全てのメンバ関数呼出の前後で常に有効であるもの。

(45p, ガイドライン 6)

#### コンセプト (Concept)

本書のコンセプトという用語は、その形を問わず、要件を表現するものを指す。
C++20 のコンセプトに加えて、テンプレート引数もコンセプトとして扱う。（テンプレート引数を指す場合の方が多い。）

(52p, ガイドライン 7)

#### フリー関数 (Free Function)

C++において、非メンバー関数を指す。

#### 依存関係逆転の原則 (DIP; Dependency Inversion Principle)

SOLID 原則の D。

> 依存関係を管理するには、具象型や実装詳細ではなく抽象化に依存すべきである、ということです。

(59p, ガイドライン 9)

> DIP も SRP の特殊な例とみなすのが妥当に思えます。（ISP と同様）。
> しかし DIP にはそれ以上のものがあります。
> SRP と比較すると、DIP はアーキテクチャに重点を置いており、正しいグローバルな依存構造を構築するのに非常に大きく影響する原則と、著者は考えます。

(68p, ガイドライン 9)

#### デザインパターン (Design Pattern)

デザインパターンは名前を持ち、明確な目的のための抽象化を導入し、長い年月をかけて検証されてきたソフトウェア設計レベルの解である。

(ガイドライン 11)

#### Visitor パターン

> 目的：あるオブジェクト構造の要素でじっこうされるオペレーションを表現する。
> Visitor パターンにより、オペレーションを加えるオブジェクトのクラスに変更を加えずに、新しいオペレーションを定義することができるようになる。

(106p, ガイドライン 16)

> Visitor パターンでは処理の追加をバリエーションポイント（中略）と考えます。
> このバリエーションポイントを切り出す、すなわち別クラスとすることで、単一責任の原則（SRP）に従っていると言えます。

(109p, ガイドライン 16)

> Visitor パターンでは処理の汎用的な追加をバリエーションポイントとし、処理の抽象化も汎用的に作成し、誰でも追加できるようにしました。
> 残念な副次効果として、型の追加が容易ではなくなってしまいました。

(145p, ガイドライン 19)

#### Strategy パターン

> Strategy パターンでのバリエーションポイントは単一関数の実装詳細です。
> この実装詳細を抽象化しても、型の追加が容易という特徴は失われません。
> しかし、処理の追加は容易ではなく、依然として仮想関数の追加という干渉が必要です。
> Strategy パターンの目的は、Visitor パターンの目的とは逆なのです。

(146p, ガイドライン 19)

> Strategy パターンがもっとも効果を発揮するのは、ごく限られた数の実装詳細を分離する場面です。多数の処理の実装詳細を切り出すような場合は、別のアプローチを検討したほうが容易でしょう（例えば External Polymorphism や Type Erasure など）。

(148p, ガイドライン 19)

> Strategy パターンは、数あるデザインパターンの中でももっとも用途が広いものです。
> （中略）とは言え、どんな問題に対処できる究極の解ではありません。

(150p, ガイドライン 19)

#### デザインパターン比較表

| パターン | バリエーションポイント | 型の追加     | 処理の追加   |
| -------- | ---------------------- | ------------ | ------------ |
| Visitor  | 処理の追加             | 容易ではない | 容易         |
| Strategy | 単一関数の実装詳細     | 容易         | 容易ではない |
