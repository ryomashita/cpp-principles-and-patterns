# Glossary of Terms

本ファイルに記載される用語の定義は、  
Klaus Iglberger 著, 千住 治郎 訳, C++ソフトウェア設計―高品質設計の原則とデザインパターン, オライリー・ジャパン, 2023  
を出典とする。

#### ソフトウェア設計 (Software Design)

> ソフトウェア設計とは、ソフトウェアコンポーネント感の依存関係を管理する技である。人工的（技術的）依存関係を最小化し、必要な抽象化を導入し、妥協点を見出すことを目的とする。

(4p, ガイドライン 1)

#### ソフトウェアアーキテクチャ (Software Architecture)

e.g., クライアント/サーバアーキテクチャ, マイクロサービス

> 普遍的に認められる一般的な定義が存在しないためです。
> （中略）
> 誰もが認める点が１つあります、ソフトウェアアーキテクチャとは、一般に全体に係る判断を下すものという点です。すなわち、将来変更するのがもっとも困難な部分です。

(6p, ガイドライン 1)

#### (C++)イディオム (C++ Idiom)

e.g., RAII, Pimpl, ...

> イディオムとは、その言語に固有とはいえ、よくある問題に対し広く用いられる解です。パターンとも言えます。

> 大雑把に言えば C++イディオムは、C++コミュニティが生んだ、設計または実装に使える実践技です。

(7p, ガイドライン 1)

#### SOLID 原則 (SOLID Principles)

> SOLID とは以降のガイドラインで述べる SRP, OCP, LSP, ISP, DIP、５つの設計原則の略語を集め、その頭文字をつなげた名前です

(10p, ガイドライン 2)

#### 単一責任の原則 (SRP; Single Responsibility Principle)

syn.: 関心の分離 (Separation of Concerns), 直交性 (Orthogonality), 凝集力 (Cohesion), 疎結合 (Loose Coupling)

> クラスを変更する理由は１つだけであるべきである

(9p, ガイドライン 2)

> SRP が言っているのは、関心と、真に属さないもの、すなわち非凝集性（癒着性）のものとを、分離すべきということです。言い換えると、変更する原因が異なるものはバリエーションポイント (variation point) に分離せよということです。

(14p, ガイドライン 2)

#### 上位 (High-level) / 下位 (Low-level)

> 上位 (high level) とはアーキテクチャで安定している部分を、
> 下位 (low level) とは多く変更されるもの、もしくは変更されやすいものを、それぞれ意味します。

(14p, ガイドライン 2)

#### バリエーションポイント (Variation Point)

> （略）バリエーションポイント、すなわちコードの変更が予想されるアスペクト

(15p, ガイドライン 2)

#### DRY 原則 (DRY; Don't Repeat Yourself)

> SRP がバリエーションポイントの分離を言うように、開発コード全体を通じ情報が重複しないよう注意すべきです。すべての場面で単一責任（変更理由は１つだけである）を実現すべきであり、個々の責任はシステム内で１ヶ所にしか存在しないようにすべきです。この考え方を一般に DRY 原則 (Don't Repeat Yourself) と言います。重要な情報を複数箇所に記述してはならない―変更が１ヶ所で済むようなシステムを設計しなさい、という意味です。

(20p, ガイドライン 2)

#### インターフェース分離の原則 (ISP; Interface Segregation Principle)

SOLID 原則の I。
使用しないメソッドへの依存をクライアントに強制すべきでない。
関心の分離が目的であり、そのための手段としてインターフェースの分離をすべきといっている。

> ISP はインターフェースに特化した、SRP の特殊なケースであるとも言えます。

(24p, ガイドライン 3)

#### 開放/閉鎖原則（OCP; Open-Closed Principle）

SOLID 原則の O。
拡張は既存のコードの改造なしに行えるべきである。
より詳しくは、同じレベル、上位レベルの既存コードで変更を発生させるべきではないが、下位レベルの変更発生は許容される。
ソフトウェアが将来どう拡張されるかを意識的に検討し、その拡張が容易に行えるよう、関心の分離を行うことを要求している。

> ソフトウェアコンポーネント（クラス、モジュール、関数など）は、拡張に対してはオープンに、改造に対してはクローズに、すべきである。

(35p, ガイドライン 5)

> OCP は SRP よりも拡張性の認識とその意識的な決定に重点を置いており、SRP の単なる付随物以上の存在と言えるでしょう。

(36p, ガイドライン 5)

#### リスコフの置換原則 (LSP; Liskov Substitution Principle)

SOLID 原則の L。
基底クラスを継承した派生クラス（サブタイプ）は、IS-A 関係を遵守（常に保証）しなければならない。

(44p, ガイドライン 6)

#### IA-A 関係 (IS-A Relationship)

あるスーパータイプ T とそのサブタイプ S について、以下のような性質を満たすときの T と S の関係を IS-A 関係という。

- サブタイプは、スーパータイプの事前条件を強化してはならない。
  - 事前条件：関数の引数に関する条件
- サブタイプは、スーパータイプの事後条件を弱めてはならない。
  - 事後条件：関数の戻り値に関する条件
- サブタイプの関数戻り値は、共変 (covariant) でなければならない。
  - 共変："サブタイプの関数の戻り値の型"が、"スーパータイプの関数の戻り値の型"のサブタイプであること
    - B が A のサブタイプならば、`B f()` は `A f()` のサブタイプである。
    - サブタイプは、戻り値でサブタイプを返せる。
- サブタイプの関数パラメータは、半変 (contravariant) でなければならない。
  - 半変："サブタイプの関数の引数の型"が、"スーパータイプの関数の引数の型"のサブタイプであること
    - B が A のサブタイプならば、`void f(B)` は `void f(A)` のサブタイプである。
    - サブタイプは、引数でスーパータイプを受け取れる。
- スーパータイプの不変条件は、サブタイプでも維持されなければならない。
  - 不変条件：タイプの状態に期待される内容で、全てのメンバ関数呼出の前後で常に有効であるもの。

(45p, ガイドライン 6)
